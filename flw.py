# -*- coding: utf-8 -*-
"""flw.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15PSo56Ze-gPNKbmMMi5XlLBk2f2YzRHi
"""

!unzip "/content/drive/MyDrive/New folder.zip" -d "/content/flowers"

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
import os
from torch.utils.data import DataLoader
from google.colab import drive
from PIL import Image

def mount_drive():
    drive.mount('/content/drive')
    dataset_path = "/content/flowers/flower17"  # Cập nhật đường dẫn tới dataset
    return dataset_path

def prepare_dataloaders(dataset_path, batch_size=32):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    train_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'train'), transform=transform)
    val_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'validation'), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, val_loader, len(train_dataset.classes), train_dataset.classes

def create_alexnet_model(num_classes):
    model = models.alexnet(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer cho số lớp
    return model

def evaluate_model(model, val_loader, device):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()
    accuracy = 100 * correct / total
    print(f'Validation Accuracy: {accuracy:.2f}%')

def train_model(model, train_loader, val_loader, num_epochs=10, learning_rate=0.001):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0

        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_acc = 100 * correct / total
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {running_loss/len(train_loader):.4f}, Accuracy: {train_acc:.2f}%")

    evaluate_model(model, val_loader, device)
    print("Training complete")

def predict_image(model, image_path, class_names):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    with torch.no_grad():
        output = model(image.to(device))
        _, predicted = output.max(1)

    predicted_class = class_names[predicted.item()]
    print(f"Predicted Flower: {predicted_class}")
    return predicted_class

def main():
    dataset_path = mount_drive()
    train_loader, val_loader, num_classes, class_names = prepare_dataloaders(dataset_path)
    model = create_alexnet_model(num_classes)
    train_model(model, train_loader, val_loader)

    test_image_path = "/content/flowers/flower17/train/bluebell/image_0251.jpg"  # Cập nhật đường dẫn ảnh test
    predict_image(model, test_image_path, class_names)

if __name__ == "__main__":
    main()

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
import os
from torch.utils.data import DataLoader
from google.colab import drive
from PIL import Image

def mount_drive():
    drive.mount('/content/drive')
    dataset_path = "/content/flowers/flower17"  # Cập nhật đường dẫn tới dataset
    return dataset_path

def prepare_dataloaders(dataset_path, batch_size=32):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    train_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'train'), transform=transform)
    val_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'validation'), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, val_loader, len(train_dataset.classes), train_dataset.classes

def create_vgg16_model(num_classes):
    model = models.vgg16(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer cho số lớp
    return model

def train_model(model, train_loader, val_loader, num_epochs=10, learning_rate=0.001):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0

        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_acc = 100 * correct / total
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {running_loss/len(train_loader):.4f}, Accuracy: {train_acc:.2f}%")

    print("Training complete")

def evaluate_model(model, val_loader, class_names):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()
    correct = 0
    total = 0

    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

    accuracy = 100 * correct / total
    print(f"Validation Accuracy: {accuracy:.2f}%")

    return accuracy

def predict_image(model, image_path, class_names):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0).to(device)

    with torch.no_grad():
        output = model(image)
        _, predicted = output.max(1)

    predicted_class = class_names[predicted.item()]
    print(f"Predicted flower: {predicted_class}")
    return predicted_class

def main():
    dataset_path = mount_drive()
    train_loader, val_loader, num_classes, class_names = prepare_dataloaders(dataset_path)
    model = create_vgg16_model(num_classes)
    train_model(model, train_loader, val_loader)
    evaluate_model(model, val_loader, class_names)

    # Dự đoán một ảnh mẫu
    sample_image_path = "/content/flowers/flower17/train/bluebell/image_0251.jpg"  # Cập nhật đường dẫn ảnh mẫu
    predict_image(model, sample_image_path, class_names)

if __name__ == "__main__":
    main()

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
import os
from torch.utils.data import DataLoader
from google.colab import drive
from PIL import Image

def mount_drive():
    drive.mount('/content/drive')
    dataset_path = "/content/flowers/flower17"  # Cập nhật đường dẫn tới dataset
    return dataset_path

def prepare_dataloaders(dataset_path, batch_size=32):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    train_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'train'), transform=transform)
    val_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'validation'), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, val_loader, len(train_dataset.classes), train_dataset.classes

def create_alexnet_model(num_classes):
    model = models.alexnet(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer cho số lớp
    return model

def create_vgg16_model(num_classes):
    model = models.vgg16(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer
    return model

def evaluate_model(model, val_loader, device):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()
    accuracy = 100 * correct / total
    print(f'Validation Accuracy: {accuracy:.2f}%')

def train_model(model, train_loader, val_loader, model_name, num_epochs=10, learning_rate=0.001):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    print(f"Training {model_name} model...")
    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0

        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_acc = 100 * correct / total
        print(f"{model_name} - Epoch {epoch+1}/{num_epochs}, Loss: {running_loss/len(train_loader):.4f}, Accuracy: {train_acc:.2f}%")

    evaluate_model(model, val_loader, device)
    print(f"{model_name} training complete")

def predict_image(model, image_path, class_names):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    with torch.no_grad():
        output = model(image.to(device))
        _, predicted = output.max(1)

    predicted_class = class_names[predicted.item()]
    print(f"Predicted Flower: {predicted_class}")
    return predicted_class

def main():
    dataset_path = mount_drive()
    train_loader, val_loader, num_classes, class_names = prepare_dataloaders(dataset_path)

    # Train and evaluate AlexNet
    alexnet_model = create_alexnet_model(num_classes)
    train_model(alexnet_model, train_loader, val_loader, "AlexNet")

    # Train and evaluate VGG16
    vgg16_model = create_vgg16_model(num_classes)
    train_model(vgg16_model, train_loader, val_loader, "VGG16")

    # Predict using the trained VGG16 model
    test_image_path =  "/content/flowers/flower17/train/bluebell/image_0251.jpg"  # Cập nhật đường dẫn ảnh test
    predict_image(vgg16_model, test_image_path, class_names)

if __name__ == "__main__":
    main()

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
import timm
import os
from torch.utils.data import DataLoader
from google.colab import drive
from PIL import Image

def mount_drive():
    drive.mount('/content/drive')
    dataset_path = "/content/flowers/flower17"  # Cập nhật đường dẫn tới dataset
    return dataset_path

def prepare_dataloaders(dataset_path, batch_size=32):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    train_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'train'), transform=transform)
    val_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'validation'), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, val_loader, len(train_dataset.classes), train_dataset.classes

def create_alexnet_model(num_classes):
    model = models.alexnet(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer cho số lớp
    return model

def create_vgg16_model(num_classes):
    model = models.vgg16(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)  # Chỉnh sửa output layer
    return model

def create_swin_model(num_classes):
    model = timm.create_model("swin_tiny_patch4_window7_224", pretrained=True, num_classes=num_classes)
    return model

def evaluate_model(model, val_loader, device):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in val_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()
    accuracy = 100 * correct / total
    print(f'Validation Accuracy: {accuracy:.2f}%')

def train_model(model, train_loader, val_loader, model_name, num_epochs=10, learning_rate=0.001):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    print(f"Training {model_name} model...")
    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0

        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item()
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_acc = 100 * correct / total
        print(f"{model_name} - Epoch {epoch+1}/{num_epochs}, Loss: {running_loss/len(train_loader):.4f}, Accuracy: {train_acc:.2f}%")

    evaluate_model(model, val_loader, device)
    print(f"{model_name} training complete")

def predict_image(model, image_path, class_names):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    with torch.no_grad():
        output = model(image.to(device))
        _, predicted = output.max(1)

    predicted_class = class_names[predicted.item()]
    print(f"Predicted Flower: {predicted_class}")
    return predicted_class

def main():
    dataset_path = mount_drive()
    train_loader, val_loader, num_classes, class_names = prepare_dataloaders(dataset_path)

    # Train and evaluate AlexNet
    alexnet_model = create_alexnet_model(num_classes)
    train_model(alexnet_model, train_loader, val_loader, "AlexNet")

    # Train and evaluate VGG16
    vgg16_model = create_vgg16_model(num_classes)
    train_model(vgg16_model, train_loader, val_loader, "VGG16")

    # Train and evaluate SWIN Transformer
    swin_model = create_swin_model(num_classes)
    train_model(swin_model, train_loader, val_loader, "SWIN Transformer")

    # Predict using the trained SWIN model
    test_image_path = "/content/flowers/flower17/train/bluebell/image_0251.jpg"  # Cập nhật đường dẫn ảnh test
    predict_image(swin_model, test_image_path, class_names)

if __name__ == "__main__":
    main()

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
import os
import numpy as np
from torch.utils.data import DataLoader
from google.colab import drive
from PIL import Image
from sklearn.neighbors import KNeighborsClassifier

def mount_drive():
    drive.mount('/content/drive')
    dataset_path = "/content/flowers/flower17"  # Cập nhật đường dẫn tới dataset
    return dataset_path

def prepare_dataloaders(dataset_path, batch_size=32):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    train_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'train'), transform=transform)
    val_dataset = datasets.ImageFolder(root=os.path.join(dataset_path, 'validation'), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, val_loader, len(train_dataset.classes), train_dataset.classes, train_dataset

def create_alexnet_model(num_classes):
    model = models.alexnet(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)
    return model

def create_vgg16_model(num_classes):
    model = models.vgg16(pretrained=True)
    model.classifier[6] = nn.Linear(4096, num_classes)
    return model

def extract_features(model, dataloader, device):
    model.eval()
    features = []
    labels = []
    with torch.no_grad():
        for images, label in dataloader:
            images = images.to(device)
            output = model.features(images)  # Trích xuất đặc trưng
            output = torch.flatten(output, start_dim=1).cpu().numpy()
            features.append(output)
            labels.append(label.numpy())
    return np.vstack(features), np.hstack(labels)

def train_knn(train_loader, model, device, k=7):
    features, labels = extract_features(model, train_loader, device)
    knn = KNeighborsClassifier(n_neighbors=k)
    knn.fit(features, labels)
    return knn

def predict_with_knn(knn, model, image_path, device, class_names):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    image = Image.open(image_path).convert('RGB')
    image = transform(image).unsqueeze(0).to(device)
    model.eval()
    with torch.no_grad():
        feature = model.features(image)
        feature = torch.flatten(feature, start_dim=1).cpu().numpy()

    predicted_label = knn.predict(feature)[0]
    print(f"Predicted Flower (KNN): {class_names[predicted_label]}")
    return class_names[predicted_label]

def evaluate_knn(knn, model, dataloader, device):
    features, labels = extract_features(model, dataloader, device)
    predictions = knn.predict(features)
    accuracy = (predictions == labels).mean() * 100
    print(f"KNN Model Accuracy: {accuracy:.2f}%")
    return accuracy

def main():
    dataset_path = mount_drive()
    train_loader, val_loader, num_classes, class_names, train_dataset = prepare_dataloaders(dataset_path)
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # Train AlexNet
    alexnet_model = create_alexnet_model(num_classes).to(device)
    knn_alexnet = train_knn(train_loader, alexnet_model, device, k=7)

    # Train VGG16
    vgg16_model = create_vgg16_model(num_classes).to(device)
    knn_vgg16 = train_knn(train_loader, vgg16_model, device, k=7)

    # Predict with KNN (AlexNet features)
    test_image_path = "/content/flowers/flower17/train/bluebell/image_0251.jpg"  # Cập nhật đường dẫn ảnh test
    evaluate_knn(knn_alexnet, alexnet_model, val_loader, device)
    predict_with_knn(knn_alexnet, alexnet_model, test_image_path, device, class_names)

    # Predict with KNN (VGG16 features)
    evaluate_knn(knn_vgg16, vgg16_model, val_loader, device)
    predict_with_knn(knn_vgg16, vgg16_model, test_image_path, device, class_names)

if __name__ == "__main__":
    main()